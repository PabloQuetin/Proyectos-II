{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS\n};\nexport default class GoTrueClient {\n  /**\n   * Create a new client for use in the browser.\n   * @param options.url The URL of the GoTrue server.\n   * @param options.headers Any additional headers to send to the GoTrue server.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.cookieOptions\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(options) {\n    this.stateChangeEmitters = new Map();\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.currentUser = null;\n    this.currentSession = null;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.multiTab = settings.multiTab;\n    this.localStorage = settings.localStorage || globalThis.localStorage;\n    this.api = new GoTrueApi({\n      url: settings.url,\n      headers: settings.headers,\n      cookieOptions: settings.cookieOptions,\n      fetch: settings.fetch\n    });\n\n    this._recoverSession();\n\n    this._recoverAndRefresh();\n\n    this._listenForMultiTabEvents();\n\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n      // Handle the OAuth redirect\n      this.getSessionFromUrl({\n        storeSession: true\n      }).then(({\n        error\n      }) => {\n        if (error) {\n          console.error('Error getting session from URL.', error);\n        }\n      });\n    }\n  }\n  /**\n   * Creates a new user.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param phone The user's phone number.\n   * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n   * @param data Optional user metadata.\n   */\n\n\n  signUp({\n    email,\n    password,\n    phone\n  }, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        const {\n          data,\n          error\n        } = phone && password ? yield this.api.signUpWithPhone(phone, password, {\n          data: options.data,\n          captchaToken: options.captchaToken\n        }) : yield this.api.signUpWithEmail(email, password, {\n          redirectTo: options.redirectTo,\n          data: options.data,\n          captchaToken: options.captchaToken\n        });\n\n        if (error) {\n          throw error;\n        }\n\n        if (!data) {\n          throw 'An error occurred on sign up.';\n        }\n\n        let session = null;\n        let user = null;\n\n        if (data.access_token) {\n          session = data;\n          user = session.user;\n\n          this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        if (data.id) {\n          user = data;\n        }\n\n        return {\n          user,\n          session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Log in an existing user, or login via a third-party provider.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param phone The user's phone number.\n   * @param password The user's password.\n   * @param refreshToken A valid refresh token that was returned on login.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n\n\n  signIn({\n    email,\n    phone,\n    password,\n    refreshToken,\n    provider,\n    oidc\n  }, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        if (email && !password) {\n          const {\n            error\n          } = yield this.api.sendMagicLinkEmail(email, {\n            redirectTo: options.redirectTo,\n            shouldCreateUser: options.shouldCreateUser,\n            captchaToken: options.captchaToken\n          });\n          return {\n            user: null,\n            session: null,\n            error\n          };\n        }\n\n        if (email && password) {\n          return this._handleEmailSignIn(email, password, {\n            redirectTo: options.redirectTo\n          });\n        }\n\n        if (phone && !password) {\n          const {\n            error\n          } = yield this.api.sendMobileOTP(phone, {\n            shouldCreateUser: options.shouldCreateUser,\n            captchaToken: options.captchaToken\n          });\n          return {\n            user: null,\n            session: null,\n            error\n          };\n        }\n\n        if (phone && password) {\n          return this._handlePhoneSignIn(phone, password);\n        }\n\n        if (refreshToken) {\n          // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n          const {\n            error\n          } = yield this._callRefreshToken(refreshToken);\n          if (error) throw error;\n          return {\n            user: this.currentUser,\n            session: this.currentSession,\n            error: null\n          };\n        }\n\n        if (provider) {\n          return this._handleProviderSignIn(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes\n          });\n        }\n\n        if (oidc) {\n          return this._handleOpenIDConnectSignIn(oidc);\n        }\n\n        throw new Error(`You must provide either an email, phone number, a third-party provider or OpenID Connect.`);\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   * @param email The user's email address.\n   * @param phone The user's phone number.\n   * @param token The user's password.\n   * @param type The user's verification type.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  verifyOTP(params, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        const {\n          data,\n          error\n        } = yield this.api.verifyOTP(params, options);\n\n        if (error) {\n          throw error;\n        }\n\n        if (!data) {\n          throw 'An error occurred on token verification.';\n        }\n\n        let session = null;\n        let user = null;\n\n        if (data.access_token) {\n          session = data;\n          user = session.user;\n\n          this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        if (data.id) {\n          user = data;\n        }\n\n        return {\n          user,\n          session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n   *\n   * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n   */\n\n\n  user() {\n    return this.currentUser;\n  }\n  /**\n   * Returns the session data, if there is an active session.\n   */\n\n\n  session() {\n    return this.currentSession;\n  }\n  /**\n   * Force refreshes the session including the user data in case it was updated in a different session.\n   */\n\n\n  refreshSession() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token)) throw new Error('Not logged in.'); // currentSession and currentUser will be updated to latest on _callRefreshToken\n\n        const {\n          error\n        } = yield this._callRefreshToken();\n        if (error) throw error;\n        return {\n          data: this.currentSession,\n          user: this.currentUser,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n\n\n  update(attributes) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token)) throw new Error('Not logged in.');\n        const {\n          user,\n          error\n        } = yield this.api.updateUser(this.currentSession.access_token, attributes);\n        if (error) throw error;\n        if (!user) throw Error('Invalid user data.');\n        const session = Object.assign(Object.assign({}, this.currentSession), {\n          user\n        });\n\n        this._saveSession(session);\n\n        this._notifyAllSubscribers('USER_UPDATED');\n\n        return {\n          data: user,\n          user,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sets the session data from refresh_token and returns current Session and Error\n   * @param refresh_token a JWT token\n   */\n\n\n  setSession(refresh_token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!refresh_token) {\n          throw new Error('No current session.');\n        }\n\n        const {\n          data,\n          error\n        } = yield this.api.refreshAccessToken(refresh_token);\n\n        if (error) {\n          return {\n            session: null,\n            error: error\n          };\n        }\n\n        this._saveSession(data);\n\n        this._notifyAllSubscribers('SIGNED_IN');\n\n        return {\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          error: e,\n          session: null\n        };\n      }\n    });\n  }\n  /**\n   * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n   * @param access_token a jwt access token\n   */\n\n\n  setAuth(access_token) {\n    this.currentSession = Object.assign(Object.assign({}, this.currentSession), {\n      access_token,\n      token_type: 'bearer',\n      user: this.user()\n    });\n    return this.currentSession;\n  }\n  /**\n   * Gets the session data from a URL string\n   * @param options.storeSession Optionally store the session in the browser\n   */\n\n\n  getSessionFromUrl(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!isBrowser()) throw new Error('No browser detected.');\n        const error_description = getParameterByName('error_description');\n        if (error_description) throw new Error(error_description);\n        const provider_token = getParameterByName('provider_token');\n        const access_token = getParameterByName('access_token');\n        if (!access_token) throw new Error('No access_token detected.');\n        const expires_in = getParameterByName('expires_in');\n        if (!expires_in) throw new Error('No expires_in detected.');\n        const refresh_token = getParameterByName('refresh_token');\n        if (!refresh_token) throw new Error('No refresh_token detected.');\n        const token_type = getParameterByName('token_type');\n        if (!token_type) throw new Error('No token_type detected.');\n        const timeNow = Math.round(Date.now() / 1000);\n        const expires_at = timeNow + parseInt(expires_in);\n        const {\n          user,\n          error\n        } = yield this.api.getUser(access_token);\n        if (error) throw error;\n        const session = {\n          provider_token,\n          access_token,\n          expires_in: parseInt(expires_in),\n          expires_at,\n          refresh_token,\n          token_type,\n          user: user\n        };\n\n        if (options === null || options === void 0 ? void 0 : options.storeSession) {\n          this._saveSession(session);\n\n          const recoveryMode = getParameterByName('type');\n\n          this._notifyAllSubscribers('SIGNED_IN');\n\n          if (recoveryMode === 'recovery') {\n            this._notifyAllSubscribers('PASSWORD_RECOVERY');\n          }\n        } // Remove tokens from URL\n\n\n        window.location.hash = '';\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n   *\n   * For server-side management, you can disable sessions by passing a JWT through to `auth.api.signOut(JWT: string)`\n   */\n\n\n  signOut() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n\n      this._removeSession();\n\n      this._notifyAllSubscribers('SIGNED_OUT');\n\n      if (accessToken) {\n        const {\n          error\n        } = yield this.api.signOut(accessToken);\n        if (error) return {\n          error\n        };\n      }\n\n      return {\n        error: null\n      };\n    });\n  }\n  /**\n   * Receive a notification every time an auth event happens.\n   * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n   */\n\n\n  onAuthStateChange(callback) {\n    try {\n      const id = uuid();\n      const subscription = {\n        id,\n        callback,\n        unsubscribe: () => {\n          this.stateChangeEmitters.delete(id);\n        }\n      };\n      this.stateChangeEmitters.set(id, subscription);\n      return {\n        data: subscription,\n        error: null\n      };\n    } catch (e) {\n      return {\n        data: null,\n        error: e\n      };\n    }\n  }\n\n  _handleEmailSignIn(email, password, options = {}) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data,\n          error\n        } = yield this.api.signInWithEmail(email, password, {\n          redirectTo: options.redirectTo\n        });\n        if (error || !data) return {\n          data: null,\n          user: null,\n          session: null,\n          error\n        };\n\n        if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n          this._saveSession(data);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        return {\n          data,\n          user: data.user,\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _handlePhoneSignIn(phone, password) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data,\n          error\n        } = yield this.api.signInWithPhone(phone, password);\n        if (error || !data) return {\n          data: null,\n          user: null,\n          session: null,\n          error\n        };\n\n        if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n          this._saveSession(data);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        return {\n          data,\n          user: data.user,\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _handleProviderSignIn(provider, options = {}) {\n    const url = this.api.getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes\n    });\n\n    try {\n      // try to open on the browser\n      if (isBrowser()) {\n        window.location.href = url;\n      }\n\n      return {\n        provider,\n        url,\n        data: null,\n        session: null,\n        user: null,\n        error: null\n      };\n    } catch (e) {\n      // fallback to returning the URL\n      if (url) return {\n        provider,\n        url,\n        data: null,\n        session: null,\n        user: null,\n        error: null\n      };\n      return {\n        data: null,\n        user: null,\n        session: null,\n        error: e\n      };\n    }\n  }\n\n  _handleOpenIDConnectSignIn({\n    id_token,\n    nonce,\n    client_id,\n    issuer,\n    provider\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (id_token && nonce && (client_id && issuer || provider)) {\n        try {\n          const {\n            data,\n            error\n          } = yield this.api.signInWithOpenIDConnect({\n            id_token,\n            nonce,\n            client_id,\n            issuer,\n            provider\n          });\n          if (error || !data) return {\n            user: null,\n            session: null,\n            error\n          };\n\n          this._saveSession(data);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n\n          return {\n            user: data.user,\n            session: data,\n            error: null\n          };\n        } catch (e) {\n          return {\n            user: null,\n            session: null,\n            error: e\n          };\n        }\n      }\n\n      throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`);\n    });\n  }\n  /**\n   * Attempts to get the session from LocalStorage\n   * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n   */\n\n\n  _recoverSession() {\n    var _a;\n\n    try {\n      const json = isBrowser() && ((_a = this.localStorage) === null || _a === void 0 ? void 0 : _a.getItem(STORAGE_KEY));\n\n      if (!json || typeof json !== 'string') {\n        return null;\n      }\n\n      const data = JSON.parse(json);\n      const {\n        currentSession,\n        expiresAt\n      } = data;\n      const timeNow = Math.round(Date.now() / 1000);\n\n      if (expiresAt >= timeNow && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n        this._saveSession(currentSession);\n\n        this._notifyAllSubscribers('SIGNED_IN');\n      }\n    } catch (error) {\n      console.log('error', error);\n    }\n  }\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n\n\n  _recoverAndRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const json = isBrowser() && (yield this.localStorage.getItem(STORAGE_KEY));\n\n        if (!json) {\n          return null;\n        }\n\n        const data = JSON.parse(json);\n        const {\n          currentSession,\n          expiresAt\n        } = data;\n        const timeNow = Math.round(Date.now() / 1000);\n\n        if (expiresAt < timeNow) {\n          if (this.autoRefreshToken && currentSession.refresh_token) {\n            const {\n              error\n            } = yield this._callRefreshToken(currentSession.refresh_token);\n\n            if (error) {\n              console.log(error.message);\n              yield this._removeSession();\n            }\n          } else {\n            this._removeSession();\n          }\n        } else if (!currentSession) {\n          console.log('Current session is missing data.');\n\n          this._removeSession();\n        } else {\n          // should be handled on _recoverSession method already\n          // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n          this._saveSession(currentSession);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n      } catch (err) {\n        console.error(err);\n        return null;\n      }\n    });\n  }\n\n  _callRefreshToken(refresh_token) {\n    var _a;\n\n    if (refresh_token === void 0) {\n      refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token;\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!refresh_token) {\n          throw new Error('No current session.');\n        }\n\n        const {\n          data,\n          error\n        } = yield this.api.refreshAccessToken(refresh_token);\n        if (error) throw error;\n        if (!data) throw Error('Invalid session data.');\n\n        this._saveSession(data);\n\n        this._notifyAllSubscribers('TOKEN_REFRESHED');\n\n        this._notifyAllSubscribers('SIGNED_IN');\n\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _notifyAllSubscribers(event) {\n    this.stateChangeEmitters.forEach(x => x.callback(event, this.currentSession));\n  }\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n\n\n  _saveSession(session) {\n    this.currentSession = session;\n    this.currentUser = session.user;\n    const expiresAt = session.expires_at;\n\n    if (expiresAt) {\n      const timeNow = Math.round(Date.now() / 1000);\n      const expiresIn = expiresAt - timeNow;\n      const refreshDurationBeforeExpires = expiresIn > 60 ? 60 : 0.5;\n\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n    } // Do we need any extra check before persist session\n    // access_token or user ?\n\n\n    if (this.persistSession && session.expires_at) {\n      this._persistSession(this.currentSession);\n    }\n  }\n\n  _persistSession(currentSession) {\n    const data = {\n      currentSession,\n      expiresAt: currentSession.expires_at\n    };\n    isBrowser() && this.localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\n  }\n\n  _removeSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.currentSession = null;\n      this.currentUser = null;\n      if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n      isBrowser() && (yield this.localStorage.removeItem(STORAGE_KEY));\n    });\n  }\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds\n   */\n\n\n  _startAutoRefreshToken(value) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n    if (value <= 0 || !this.autoRefreshToken) return;\n    this.refreshTokenTimer = setTimeout(() => this._callRefreshToken(), value);\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n  }\n  /**\n   * Listens for changes to LocalStorage and updates the current session.\n   */\n\n\n  _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      // console.debug('Auth multi-tab support is disabled.')\n      return false;\n    }\n\n    try {\n      window === null || window === void 0 ? void 0 : window.addEventListener('storage', e => {\n        var _a;\n\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue));\n\n          if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n            this._recoverAndRefresh();\n\n            this._notifyAllSubscribers('SIGNED_IN');\n          } else {\n            this._removeSession();\n\n            this._notifyAllSubscribers('SIGNED_OUT');\n          }\n        }\n      });\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error);\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/rafit/Desktop/Nueva carpeta/tabs/node_modules/@supabase/gotrue-js/dist/module/GoTrueClient.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","GoTrueApi","isBrowser","getParameterByName","uuid","GOTRUE_URL","DEFAULT_HEADERS","STORAGE_KEY","polyfillGlobalThis","DEFAULT_OPTIONS","url","autoRefreshToken","persistSession","detectSessionInUrl","multiTab","headers","GoTrueClient","constructor","options","stateChangeEmitters","Map","settings","Object","assign","currentUser","currentSession","localStorage","globalThis","api","cookieOptions","fetch","_recoverSession","_recoverAndRefresh","_listenForMultiTabEvents","getSessionFromUrl","storeSession","error","console","signUp","email","password","phone","_removeSession","data","signUpWithPhone","captchaToken","signUpWithEmail","redirectTo","session","user","access_token","_saveSession","_notifyAllSubscribers","id","signIn","refreshToken","provider","oidc","sendMagicLinkEmail","shouldCreateUser","_handleEmailSignIn","sendMobileOTP","_handlePhoneSignIn","_callRefreshToken","_handleProviderSignIn","scopes","_handleOpenIDConnectSignIn","Error","verifyOTP","params","refreshSession","_a","update","attributes","updateUser","setSession","refresh_token","refreshAccessToken","setAuth","token_type","error_description","provider_token","expires_in","timeNow","Math","round","Date","now","expires_at","parseInt","getUser","recoveryMode","window","location","hash","signOut","accessToken","onAuthStateChange","callback","subscription","unsubscribe","delete","set","_b","signInWithEmail","confirmed_at","email_confirmed_at","signInWithPhone","phone_confirmed_at","getUrlForProvider","href","id_token","nonce","client_id","issuer","signInWithOpenIDConnect","json","getItem","JSON","parse","expiresAt","log","message","err","event","forEach","x","expiresIn","refreshDurationBeforeExpires","_startAutoRefreshToken","_persistSession","setItem","stringify","refreshTokenTimer","clearTimeout","removeItem","setTimeout","unref","addEventListener","key","newSession","String","newValue"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: GOTRUE_URL,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    multiTab: true,\n    headers: DEFAULT_HEADERS,\n};\nexport default class GoTrueClient {\n    /**\n     * Create a new client for use in the browser.\n     * @param options.url The URL of the GoTrue server.\n     * @param options.headers Any additional headers to send to the GoTrue server.\n     * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n     * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n     * @param options.cookieOptions\n     * @param options.fetch A custom fetch implementation.\n     */\n    constructor(options) {\n        this.stateChangeEmitters = new Map();\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.currentUser = null;\n        this.currentSession = null;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.persistSession = settings.persistSession;\n        this.multiTab = settings.multiTab;\n        this.localStorage = settings.localStorage || globalThis.localStorage;\n        this.api = new GoTrueApi({\n            url: settings.url,\n            headers: settings.headers,\n            cookieOptions: settings.cookieOptions,\n            fetch: settings.fetch,\n        });\n        this._recoverSession();\n        this._recoverAndRefresh();\n        this._listenForMultiTabEvents();\n        if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n            // Handle the OAuth redirect\n            this.getSessionFromUrl({ storeSession: true }).then(({ error }) => {\n                if (error) {\n                    console.error('Error getting session from URL.', error);\n                }\n            });\n        }\n    }\n    /**\n     * Creates a new user.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param password The user's password.\n     * @param phone The user's phone number.\n     * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n     * @param data Optional user metadata.\n     */\n    signUp({ email, password, phone }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                const { data, error } = phone && password\n                    ? yield this.api.signUpWithPhone(phone, password, {\n                        data: options.data,\n                        captchaToken: options.captchaToken,\n                    })\n                    : yield this.api.signUpWithEmail(email, password, {\n                        redirectTo: options.redirectTo,\n                        data: options.data,\n                        captchaToken: options.captchaToken,\n                    });\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw 'An error occurred on sign up.';\n                }\n                let session = null;\n                let user = null;\n                if (data.access_token) {\n                    session = data;\n                    user = session.user;\n                    this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) {\n                    user = data;\n                }\n                return { user, session, error: null };\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Log in an existing user, or login via a third-party provider.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param password The user's password.\n     * @param refreshToken A valid refresh token that was returned on login.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */\n    signIn({ email, phone, password, refreshToken, provider, oidc }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                if (email && !password) {\n                    const { error } = yield this.api.sendMagicLinkEmail(email, {\n                        redirectTo: options.redirectTo,\n                        shouldCreateUser: options.shouldCreateUser,\n                        captchaToken: options.captchaToken,\n                    });\n                    return { user: null, session: null, error };\n                }\n                if (email && password) {\n                    return this._handleEmailSignIn(email, password, {\n                        redirectTo: options.redirectTo,\n                    });\n                }\n                if (phone && !password) {\n                    const { error } = yield this.api.sendMobileOTP(phone, {\n                        shouldCreateUser: options.shouldCreateUser,\n                        captchaToken: options.captchaToken,\n                    });\n                    return { user: null, session: null, error };\n                }\n                if (phone && password) {\n                    return this._handlePhoneSignIn(phone, password);\n                }\n                if (refreshToken) {\n                    // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n                    const { error } = yield this._callRefreshToken(refreshToken);\n                    if (error)\n                        throw error;\n                    return {\n                        user: this.currentUser,\n                        session: this.currentSession,\n                        error: null,\n                    };\n                }\n                if (provider) {\n                    return this._handleProviderSignIn(provider, {\n                        redirectTo: options.redirectTo,\n                        scopes: options.scopes,\n                    });\n                }\n                if (oidc) {\n                    return this._handleOpenIDConnectSignIn(oidc);\n                }\n                throw new Error(`You must provide either an email, phone number, a third-party provider or OpenID Connect.`);\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param token The user's password.\n     * @param type The user's verification type.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    verifyOTP(params, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                const { data, error } = yield this.api.verifyOTP(params, options);\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw 'An error occurred on token verification.';\n                }\n                let session = null;\n                let user = null;\n                if (data.access_token) {\n                    session = data;\n                    user = session.user;\n                    this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) {\n                    user = data;\n                }\n                return { user, session, error: null };\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n     *\n     * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n     */\n    user() {\n        return this.currentUser;\n    }\n    /**\n     * Returns the session data, if there is an active session.\n     */\n    session() {\n        return this.currentSession;\n    }\n    /**\n     * Force refreshes the session including the user data in case it was updated in a different session.\n     */\n    refreshSession() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))\n                    throw new Error('Not logged in.');\n                // currentSession and currentUser will be updated to latest on _callRefreshToken\n                const { error } = yield this._callRefreshToken();\n                if (error)\n                    throw error;\n                return { data: this.currentSession, user: this.currentUser, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, error: e };\n            }\n        });\n    }\n    /**\n     * Updates user data, if there is a logged in user.\n     */\n    update(attributes) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))\n                    throw new Error('Not logged in.');\n                const { user, error } = yield this.api.updateUser(this.currentSession.access_token, attributes);\n                if (error)\n                    throw error;\n                if (!user)\n                    throw Error('Invalid user data.');\n                const session = Object.assign(Object.assign({}, this.currentSession), { user });\n                this._saveSession(session);\n                this._notifyAllSubscribers('USER_UPDATED');\n                return { data: user, user, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sets the session data from refresh_token and returns current Session and Error\n     * @param refresh_token a JWT token\n     */\n    setSession(refresh_token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!refresh_token) {\n                    throw new Error('No current session.');\n                }\n                const { data, error } = yield this.api.refreshAccessToken(refresh_token);\n                if (error) {\n                    return { session: null, error: error };\n                }\n                this._saveSession(data);\n                this._notifyAllSubscribers('SIGNED_IN');\n                return { session: data, error: null };\n            }\n            catch (e) {\n                return { error: e, session: null };\n            }\n        });\n    }\n    /**\n     * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n     * @param access_token a jwt access token\n     */\n    setAuth(access_token) {\n        this.currentSession = Object.assign(Object.assign({}, this.currentSession), { access_token, token_type: 'bearer', user: this.user() });\n        return this.currentSession;\n    }\n    /**\n     * Gets the session data from a URL string\n     * @param options.storeSession Optionally store the session in the browser\n     */\n    getSessionFromUrl(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!isBrowser())\n                    throw new Error('No browser detected.');\n                const error_description = getParameterByName('error_description');\n                if (error_description)\n                    throw new Error(error_description);\n                const provider_token = getParameterByName('provider_token');\n                const access_token = getParameterByName('access_token');\n                if (!access_token)\n                    throw new Error('No access_token detected.');\n                const expires_in = getParameterByName('expires_in');\n                if (!expires_in)\n                    throw new Error('No expires_in detected.');\n                const refresh_token = getParameterByName('refresh_token');\n                if (!refresh_token)\n                    throw new Error('No refresh_token detected.');\n                const token_type = getParameterByName('token_type');\n                if (!token_type)\n                    throw new Error('No token_type detected.');\n                const timeNow = Math.round(Date.now() / 1000);\n                const expires_at = timeNow + parseInt(expires_in);\n                const { user, error } = yield this.api.getUser(access_token);\n                if (error)\n                    throw error;\n                const session = {\n                    provider_token,\n                    access_token,\n                    expires_in: parseInt(expires_in),\n                    expires_at,\n                    refresh_token,\n                    token_type,\n                    user: user,\n                };\n                if (options === null || options === void 0 ? void 0 : options.storeSession) {\n                    this._saveSession(session);\n                    const recoveryMode = getParameterByName('type');\n                    this._notifyAllSubscribers('SIGNED_IN');\n                    if (recoveryMode === 'recovery') {\n                        this._notifyAllSubscribers('PASSWORD_RECOVERY');\n                    }\n                }\n                // Remove tokens from URL\n                window.location.hash = '';\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n     *\n     * For server-side management, you can disable sessions by passing a JWT through to `auth.api.signOut(JWT: string)`\n     */\n    signOut() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n            this._removeSession();\n            this._notifyAllSubscribers('SIGNED_OUT');\n            if (accessToken) {\n                const { error } = yield this.api.signOut(accessToken);\n                if (error)\n                    return { error };\n            }\n            return { error: null };\n        });\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n     */\n    onAuthStateChange(callback) {\n        try {\n            const id = uuid();\n            const subscription = {\n                id,\n                callback,\n                unsubscribe: () => {\n                    this.stateChangeEmitters.delete(id);\n                },\n            };\n            this.stateChangeEmitters.set(id, subscription);\n            return { data: subscription, error: null };\n        }\n        catch (e) {\n            return { data: null, error: e };\n        }\n    }\n    _handleEmailSignIn(email, password, options = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data, error } = yield this.api.signInWithEmail(email, password, {\n                    redirectTo: options.redirectTo,\n                });\n                if (error || !data)\n                    return { data: null, user: null, session: null, error };\n                if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return { data, user: data.user, session: data, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, session: null, error: e };\n            }\n        });\n    }\n    _handlePhoneSignIn(phone, password) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data, error } = yield this.api.signInWithPhone(phone, password);\n                if (error || !data)\n                    return { data: null, user: null, session: null, error };\n                if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return { data, user: data.user, session: data, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, session: null, error: e };\n            }\n        });\n    }\n    _handleProviderSignIn(provider, options = {}) {\n        const url = this.api.getUrlForProvider(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n        });\n        try {\n            // try to open on the browser\n            if (isBrowser()) {\n                window.location.href = url;\n            }\n            return { provider, url, data: null, session: null, user: null, error: null };\n        }\n        catch (e) {\n            // fallback to returning the URL\n            if (url)\n                return { provider, url, data: null, session: null, user: null, error: null };\n            return { data: null, user: null, session: null, error: e };\n        }\n    }\n    _handleOpenIDConnectSignIn({ id_token, nonce, client_id, issuer, provider, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (id_token && nonce && ((client_id && issuer) || provider)) {\n                try {\n                    const { data, error } = yield this.api.signInWithOpenIDConnect({\n                        id_token,\n                        nonce,\n                        client_id,\n                        issuer,\n                        provider,\n                    });\n                    if (error || !data)\n                        return { user: null, session: null, error };\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                    return { user: data.user, session: data, error: null };\n                }\n                catch (e) {\n                    return { user: null, session: null, error: e };\n                }\n            }\n            throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`);\n        });\n    }\n    /**\n     * Attempts to get the session from LocalStorage\n     * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n     */\n    _recoverSession() {\n        var _a;\n        try {\n            const json = isBrowser() && ((_a = this.localStorage) === null || _a === void 0 ? void 0 : _a.getItem(STORAGE_KEY));\n            if (!json || typeof json !== 'string') {\n                return null;\n            }\n            const data = JSON.parse(json);\n            const { currentSession, expiresAt } = data;\n            const timeNow = Math.round(Date.now() / 1000);\n            if (expiresAt >= timeNow && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n                this._saveSession(currentSession);\n                this._notifyAllSubscribers('SIGNED_IN');\n            }\n        }\n        catch (error) {\n            console.log('error', error);\n        }\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n    _recoverAndRefresh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const json = isBrowser() && (yield this.localStorage.getItem(STORAGE_KEY));\n                if (!json) {\n                    return null;\n                }\n                const data = JSON.parse(json);\n                const { currentSession, expiresAt } = data;\n                const timeNow = Math.round(Date.now() / 1000);\n                if (expiresAt < timeNow) {\n                    if (this.autoRefreshToken && currentSession.refresh_token) {\n                        const { error } = yield this._callRefreshToken(currentSession.refresh_token);\n                        if (error) {\n                            console.log(error.message);\n                            yield this._removeSession();\n                        }\n                    }\n                    else {\n                        this._removeSession();\n                    }\n                }\n                else if (!currentSession) {\n                    console.log('Current session is missing data.');\n                    this._removeSession();\n                }\n                else {\n                    // should be handled on _recoverSession method already\n                    // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n                    this._saveSession(currentSession);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n            }\n            catch (err) {\n                console.error(err);\n                return null;\n            }\n        });\n    }\n    _callRefreshToken(refresh_token) {\n        var _a;\n        if (refresh_token === void 0) { refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token; }\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!refresh_token) {\n                    throw new Error('No current session.');\n                }\n                const { data, error } = yield this.api.refreshAccessToken(refresh_token);\n                if (error)\n                    throw error;\n                if (!data)\n                    throw Error('Invalid session data.');\n                this._saveSession(data);\n                this._notifyAllSubscribers('TOKEN_REFRESHED');\n                this._notifyAllSubscribers('SIGNED_IN');\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    _notifyAllSubscribers(event) {\n        this.stateChangeEmitters.forEach((x) => x.callback(event, this.currentSession));\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n    _saveSession(session) {\n        this.currentSession = session;\n        this.currentUser = session.user;\n        const expiresAt = session.expires_at;\n        if (expiresAt) {\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = expiresAt - timeNow;\n            const refreshDurationBeforeExpires = expiresIn > 60 ? 60 : 0.5;\n            this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n        }\n        // Do we need any extra check before persist session\n        // access_token or user ?\n        if (this.persistSession && session.expires_at) {\n            this._persistSession(this.currentSession);\n        }\n    }\n    _persistSession(currentSession) {\n        const data = { currentSession, expiresAt: currentSession.expires_at };\n        isBrowser() && this.localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\n    }\n    _removeSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.currentSession = null;\n            this.currentUser = null;\n            if (this.refreshTokenTimer)\n                clearTimeout(this.refreshTokenTimer);\n            isBrowser() && (yield this.localStorage.removeItem(STORAGE_KEY));\n        });\n    }\n    /**\n     * Clear and re-create refresh token timer\n     * @param value time intervals in milliseconds\n     */\n    _startAutoRefreshToken(value) {\n        if (this.refreshTokenTimer)\n            clearTimeout(this.refreshTokenTimer);\n        if (value <= 0 || !this.autoRefreshToken)\n            return;\n        this.refreshTokenTimer = setTimeout(() => this._callRefreshToken(), value);\n        if (typeof this.refreshTokenTimer.unref === 'function')\n            this.refreshTokenTimer.unref();\n    }\n    /**\n     * Listens for changes to LocalStorage and updates the current session.\n     */\n    _listenForMultiTabEvents() {\n        if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            // console.debug('Auth multi-tab support is disabled.')\n            return false;\n        }\n        try {\n            window === null || window === void 0 ? void 0 : window.addEventListener('storage', (e) => {\n                var _a;\n                if (e.key === STORAGE_KEY) {\n                    const newSession = JSON.parse(String(e.newValue));\n                    if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n                        this._recoverAndRefresh();\n                        this._notifyAllSubscribers('SIGNED_IN');\n                    }\n                    else {\n                        this._removeSession();\n                        this._notifyAllSubscribers('SIGNED_OUT');\n                    }\n                }\n            });\n        }\n        catch (error) {\n            console.error('_listenForMultiTabEvents', error);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}